const PDFDocument = require('pdfkit');
const fs = require('fs');
const path = require('path');

exports.generatePDF = async (analysisData) => {
  return new Promise((resolve, reject) => {
    try {
      const doc = new PDFDocument({
        margin: 50,
        size: 'A4'
      });

      const chunks = [];
      
      doc.on('data', chunk => chunks.push(chunk));
      doc.on('end', () => resolve(Buffer.concat(chunks)));
      doc.on('error', reject);

      // Add content
      generatePDFContent(doc, analysisData);
      
      doc.end();
    } catch (error) {
      reject(error);
    }
  });
};

function generatePDFContent(doc, data) {
  // Header
  doc.fontSize(24)
     .text('RepoInsight Pro Analysis Report', { align: 'center' })
     .moveDown();

  doc.fontSize(12)
     .text(`Generated: ${new Date().toLocaleString()}`)
     .text(`Repository: ${data.repository.name}`)
     .text(`Owner: ${data.repository.owner}`)
     .moveDown();

  // Overall Score
  doc.fontSize(18)
     .text('Overall Score', { underline: true })
     .moveDown(0.5);

  const overallScore = data.scores.overall;
  const scoreColor = getScoreColor(overallScore);
  
  doc.fontSize(36)
     .fillColor(scoreColor)
     .text(`${overallScore}/100`, { align: 'center' })
     .moveDown();

  doc.fillColor('black');

  // Score Breakdown
  doc.fontSize(16)
     .text('Score Breakdown', { underline: true })
     .moveDown(0.5);

  const scoreCategories = [
    { label: 'Code Quality', score: data.scores.codeQuality },
    { label: 'Documentation', score: data.scores.documentation },
    { label: 'Testing', score: data.scores.testing },
    { label: 'CI/CD', score: data.scores.ciCd },
    { label: 'Maintainability', score: data.scores.maintainability },
    { label: 'Collaboration', score: data.scores.collaboration }
  ];

  scoreCategories.forEach(category => {
    doc.fontSize(12)
       .text(`${category.label}:`, { continued: true })
       .fillColor(getScoreColor(category.score))
       .text(` ${category.score}/100`)
       .fillColor('black');
  });

  doc.moveDown();

  // Badges
  if (data.badges && data.badges.length > 0) {
    doc.fontSize(16)
       .text('Earned Badges', { underline: true })
       .moveDown(0.5);

    data.badges.forEach((badge, index) => {
      if (index % 2 === 0 && index > 0) doc.moveDown(0.5);
      
      doc.fontSize(10)
         .text(`${badge.icon} ${badge.name} (${badge.level}) - ${badge.description}`);
    });

    doc.moveDown();
  }

  // AI Analysis Summary
  if (data.analysis) {
    doc.fontSize(16)
       .text('AI Analysis Summary', { underline: true })
       .moveDown(0.5);

    doc.fontSize(11)
       .text(data.analysis.summary || 'No summary available')
       .moveDown();

    // Strengths
    if (data.analysis.strengths && data.analysis.strengths.length > 0) {
      doc.fontSize(14)
         .text('Strengths:', { underline: true })
         .moveDown(0.5);

      data.analysis.strengths.forEach(strength => {
        doc.fontSize(10)
           .text(`• ${strength}`);
      });

      doc.moveDown();
    }

    // Weaknesses
    if (data.analysis.weaknesses && data.analysis.weaknesses.length > 0) {
      doc.fontSize(14)
         .text('Areas for Improvement:', { underline: true })
         .moveDown(0.5);

      data.analysis.weaknesses.forEach(weakness => {
        doc.fontSize(10)
           .text(`• ${weakness}`);
      });

      doc.moveDown();
    }

    // Recommendations
    if (data.analysis.recommendations && data.analysis.recommendations.length > 0) {
      doc.fontSize(14)
         .text('Recommendations:', { underline: true })
         .moveDown(0.5);

      data.analysis.recommendations.forEach(recommendation => {
        doc.fontSize(10)
           .text(`• ${recommendation}`);
      });

      doc.moveDown();
    }
  }

  // Roadmap
  if (data.analysis.roadmap && data.analysis.roadmap.length > 0) {
    doc.addPage()
       .fontSize(16)
       .text('Improvement Roadmap', { align: 'center', underline: true })
       .moveDown();

    data.analysis.roadmap.forEach(week => {
      doc.fontSize(14)
         .text(`Week ${week.week}: ${week.theme}`, { underline: true })
         .moveDown(0.5);

      if (week.tasks && week.tasks.length > 0) {
        week.tasks.forEach(task => {
          doc.fontSize(10)
             .text(`• ${task.title} (${task.priority} Priority)`, { indent: 20 })
             .moveDown(0.2);
          
          if (task.description) {
            doc.fontSize(9)
               .text(`  ${task.description}`, { indent: 40 })
               .moveDown(0.2);
          }
        });
      }

      doc.moveDown();
    });
  }

  // Footer
  doc.addPage()
     .fontSize(10)
     .text('Generated by RepoInsight Pro AI', { align: 'center' })
     .text('https://repoinsight.pro', { align: 'center', link: 'https://repoinsight.pro' })
     .text('Confidential Report - For Developer Use Only', { align: 'center' });
}

function getScoreColor(score) {
  if (score >= 80) return '#4CAF50'; // Green
  if (score >= 60) return '#FF9800'; // Orange
  return '#F44336'; // Red
}

exports.generateComparisonPDF = async (comparisonData) => {
  return new Promise((resolve, reject) => {
    try {
      const doc = new PDFDocument({
        margin: 50,
        size: 'A4'
      });

      const chunks = [];
      
      doc.on('data', chunk => chunks.push(chunk));
      doc.on('end', () => resolve(Buffer.concat(chunks)));
      doc.on('error', reject);

      // Comparison report content
      doc.fontSize(24)
         .text('Repository Comparison Report', { align: 'center' })
         .moveDown();

      // Repository 1
      doc.fontSize(16)
         .text('Repository 1:', { underline: true })
         .moveDown(0.5)
         .fontSize(12)
         .text(`Name: ${comparisonData.repo1.data.name}`)
         .text(`Owner: ${comparisonData.repo1.data.owner}`)
         .text(`Score: ${comparisonData.repo1.scores.overall}/100`)
         .moveDown();

      // Repository 2
      doc.fontSize(16)
         .text('Repository 2:', { underline: true })
         .moveDown(0.5)
         .fontSize(12)
         .text(`Name: ${comparisonData.repo2.data.name}`)
         .text(`Owner: ${comparisonData.repo2.data.owner}`)
         .text(`Score: ${comparisonData.repo2.scores.overall}/100`)
         .moveDown();

      // Comparison
      doc.fontSize(16)
         .text('Comparison Results:', { underline: true })
         .moveDown(0.5);

      const diff = comparisonData.differences.overall;
      const betterRepo = diff > 0 ? 'Repository 1' : 'Repository 2';
      const diffAbs = Math.abs(diff);

      doc.fontSize(12)
         .text(`${betterRepo} is ${diffAbs} points better`)
         .moveDown();

      doc.end();
    } catch (error) {
      reject(error);
    }
  });
};